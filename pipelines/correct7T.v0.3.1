#!/bin/bash



#pipeline for running gradient correction & sa2rage+mp2rage B1 correction

function usage {

  echo "autobids script for running standard correction and QC pipelines for 7T. Puts results in <bids_dir>/../$scriptname " 
  echo " By default: will only process subjects that were most recently imported by autobids"
  echo "" 
  echo "Usage: $0 [ [-a] [-t] [-o OUT_DIR] [-s SUBJID] [-S SUBJLIST]  ]  BIDS_DIR  [ <bidsBatch options> ...] "
  echo ""
  echo " optional flags (place these *before* bids_dir):"
  echo "  -a:  process all subjects, not just most recently imported (note: this will not re-run existing results, remove files first to do that)"
  echo "  -o <out_dir>:  override output folder"
  echo "  -s <subjid>: run on single subject"
  echo "  -S <subjlist_txt>: run on subject list"
  echo "  -t : test mode (don't submit jobs)"
  echo "  -g <grad_coeff_file>: run gradient correction with custom coefficient file"
  echo "  -m <custom_mp2rage_param_csv>: run mp2rage correction with custom mp2rage_param file"
  echo "  -n <custom_sa2rage_param_csv>: run mp2rage correction with custom sa2rage_param file"

  echo ""


}


scriptname=$0
scriptname=${scriptname##*/}




if [ "$#" -lt 1 ]
then
  usage
  exit 1
fi

out_dir=

process_mode=recent
# other options: all, subj, subjlist

s_opts=""
opts=""
grad_coeff=""
mp2rage_param_csv=""
sa2rage_param_csv=""

while getopts "ato:s:S:g:n:m" options; do
 case $options in
    a ) echo "	Running on all subjects" >&2
	process_mode=all;;
    o ) echo "	Overriding output dir as: $OPTARG"  >&2
	out_dir=$OPTARG;;
    s ) echo "  Running on single subject: $OPTARG" >&2
	process_mode=subj
    	opts="$opts -s $OPTARG";;
    S ) echo "  Running on a subject list: $OPTARG" >&2
	 process_mode=subjlist
   	 opts="$opts -S $OPTARG";;
    t ) echo "  Using test mode, not submitting any jobs.." >&2
	 s_opts="$sopts -t"
	 opts="$opts -t";;
    g ) echo "	Running gradient correction with custrom coefficient file: $OPTARG" >&2
	grad_coeff=$OPTARG;;
    n ) echo "	Running MP2RAGE correction with custom sa2rage parameter csv: $OPTARG" >&2
    	sa2rage_param_csv=$OPTARG;;
    m ) echo "	Running MP2RAGE correction with custom mp2rage parameter csv: $OPTARG" >&2
	mp2rage_param_csv=$OPTARG;;
    * ) usage
	exit 1;;
 esac
done

shift $((OPTIND-1))



bids_dir=$1  		#path to bids dir
shift 1 
opts="$opts $@"


#make abs path:
bids_dir=`realpath $bids_dir`

if [ "$process_mode" = "recent" ]
then

#by default, only run on the most recently submitted subjects
subjlist=`ls -1t $bids_dir/code/*/subjects-list.txt 2> /dev/null | head -n 1`
if [ -n "$subjlist" ]
then

if [ -e $subjlist ]
then
	nsubj=`cat $subjlist | wc -l`
	if [ "$nsubj" = "1" ]
	then
		subjid=`cat $subjlist`
		opts="$opts -s $subjid"
	else
		opts="$opts -S $subjlist"
	fi
fi

else
	echo "No subjects-list.txt found in $bids_dir/code/* folder, running on ALL subjects"
fi
fi


if [ ! -n "$out_dir" ]
then
	out_dir=$bids_dir/../$scriptname
	echo "Using default output directory: $out_dir"
fi	

mkdir -p $out_dir

bids_dir=`realpath $bids_dir`
out_dir=`realpath $out_dir`

gradcorrect_app=gradcorrect_v0.0.3a
mp2rage_correction_app=mp2rage_correction_v0.0.4a
qsm_app=qsm_sstv_v0.1.1
beast_app=beast_v0.0.2
prepdwi_app=prepdwi_v0.0.12c_7T
fmriprep_app=fmriprep_1.5.0
mriqc_app=mriqc_0.15.1

#checks if custom grad_coeff exists and runs gradient correction
if [ -e $grad_coeff ]
then
	job1=$(bidsBatch $opts $gradcorrect_app $bids_dir ${out_dir}/$gradcorrect_app participant --grad_coeff_file ${grad_coeff})	
else
	job1=$(bidsBatch $opts $gradcorrect_app $bids_dir ${out_dir}/$gradcorrect_app participant)
fi

#run participant-level mriqc
jobqc=$(bidsBatch $opts $mriqc_app $bids_dir ${out_dir}/$mriqc_app participant)

#run group-level mriqc
bidsBatch -d afterany:$jobqc $opts $mriqc_app $bids_dir ${out_dir}/$mriqc_app group

#these submit a job when gradcorrect is done, which then runs bidsBatch (needed since bidsBatch requires the input dataset to be complete when the job is run)


hasBIDS $bids_dir anat MP2RAGE && \
hasBIDS $bids_dir fmap SA2RAGE && \
	mkdir -p ${out_dir}/$mp2rage_correction_app/code && pushd ${out_dir}/$mp2rage_correction_app/code && \

#checks if there are custom mp2rage_param_csv files and runs appropriate command
if [[ -e $mp2rage_param_csv ]] || [[ -e $sa2rage_param_csv ]]
then 
	regularSubmit -N run_$mp2rage_correction_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $mp2rage_correction_app  ${out_dir}/$gradcorrect_app ${out_dir}/$mp2rage_correction_app participant --mp2rage_param_csv ${mp2rage_param_csv} --sa2rage_param_csv ${sa2rage_param_csv} && popd	
	
elif [[ -e $mp2rage_param_csv ]] || [[ ! -e $sa2rage_param_csv ]]
then
	regularSubmit -N run_$mp2rage_correction_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $mp2rage_correction_app  ${out_dir}/$gradcorrect_app ${out_dir}/$mp2rage_correction_app participant --mp2rage_param_csv ${mp2rage_param_csv} && popd
	
elif [[ ! -e $mp2rage_param_csv ]] || [[ -e $sa2rage_param_csv ]]
then
	regularSubmit -N run_$mp2rage_correction_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $mp2rage_correction_app  ${out_dir}/$gradcorrect_app ${out_dir}/$mp2rage_correction_app participant --sa2rage_param_csv ${sa2rage_param_csv} && popd

else
	regularSubmit -N run_$mp2rage_correction_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $mp2rage_correction_app  ${out_dir}/$gradcorrect_app ${out_dir}/$mp2rage_correction_app participant && popd	
fi

hasBIDS $bids_dir anat GRE && \
	mkdir -p ${out_dir}/$qsm_app/code && pushd ${out_dir}/$qsm_app/code && \
	regularSubmit -N run_$qsm_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $qsm_app  ${out_dir}/$gradcorrect_app ${out_dir}/$qsm_app participant && popd

hasBIDS $bids_dir anat T1w && \
	mkdir -p ${out_dir}/$beast_app/code && pushd ${out_dir}/$beast_app/code && \
	regularSubmit -N run_$beast_app -j Quick -d afterany:$job1 $s_opts bidsBatch $opts $beast_app  ${out_dir}/$gradcorrect_app ${out_dir}/$beast_app participant && popd


#to track dependencies of the run_* jobs:
#  need to 1) submit a job that is dependent on run_* completing successfully, and
#  that job parses the output of the run_* job to get the job id of the job it submitted, 
#  and submits a run job that is dependent on that..


#leave prepdwi out for now, since unable to monitor completion of beast_app dependency
#regularSubmit -j Quick -d afterany:$job1 bidsBatch $opts $prepdwi_app  $bids_dir  ${out_dir}/$prepdwi_app participant --in_brainmask_dir ${out_dir}/$beast_app


echo $job1

exit 0
